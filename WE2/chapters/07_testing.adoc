== Testing
=== Testarten
*Static*: Statische Code-Analyse.
*Unit*: Testen einer einzelnen Komponente [.smaller]#(Klasse, Modul, etc.)#.
*Integration*: Testen von mehreren Komponenten.
*E2E/System*: Testen von allen Komponenten.
*Funktional*: Testen von konkreten Anforderungen [.smaller]#(Use-Cases)#.
*Regression*: Testen auf potenzielle Fehler nach Code-Änderungen.
*Weiteres*: Testen von Security, Usability, Performance, Stress, etc.

footnote:[Oft wird dabei von einem System Under Test (SUT) gesprochen.]

=== Begriffe & Tools
*Test-Gruppe/Fixture*: Beinhaltet die Tests.
*Test-Environment*: Umgebung, in der Tests ausgeführt werden.
*Doubles/Mocks*: Fake-Klassen fürs Testen.
*Phasen*: Setup, Exercise, Verify, Teardown

*Assertion Libraries*: Erlauben eine einfache Spezifikation von Tests [.smaller]#(Chai, Expect.js)#.
*Test-Runners*: Führen die Tests aus [.smaller]#(Mocha, Cypress, Jest)#.
*Mocking Libraries*: Erlauben die Erstellung von Mocks [.smaller]#(Proxyquire, Sinon.js)#.
*DOM-Handling*: Erlauben das Testen von Web-UIs [.smaller]#(Cypress, Puppeteer)#.

footnote:[Achtung: Teilweise wird auch das Test-Environment als "Fixture" bezeichnet.]
footnote:[Assertion Libraries könnten auch durch `throw new Error (...)` ersetzt werden.]

=== Prinzipen & Test Smells
Alles Testen, das kaputt ging oder gehen könnte.
Neuer Code ist immer "schuldig".
Vor einem Push alle Tests laufen lassen.
Mocks/Doubles mittels Dependency Injection zulassen.

*Smells*:
Hard-to-Test Code,
Production Bugs,
Fragile Tests [.smaller]#(Stark abhängig von interner Logik)#,
Erratic Tests [.smaller]#(Zufällig Pass/Fail)#,
Developers not Writing Tests,
Assertion Roulette [.smaller]#(Zu viele Assertions in einem Test)#,
Test Logic in Production Code,
Obscure Tests [.smaller]#(Zu kompliziert)#,
Slow Tests,
Test Code Duplication,
Conditional Test Logic.

=== Mocha/Chai
Erlauben Unit-/Integration-Tests.
*Syntax*: `expect(...).to.equal(val)`, `.to.be.false`, `.to.be.a(number)`, `.to.deep.equal(array)`, `.to.throw(TypeError)`, `to.not.be.undefined`, `.to.have.any.key(key)`, ...

[source, javascript]
----
import chai, {expect} from 'chai'
import chaiHttp from 'chai-http';
import jsdom from 'jsdom';
import app from './app.js'
chai.use(chaiHttp);
describe('Mocha-Chai-Fixture', () => {
    let aNumber;
    beforeEach(() => { aNumber = 1 })       // Setup
    it('Unit: Changed value is new value', () => {
        aNumber = 2                         // Exercise
        expect(aNumber).to.equal(2)         // Verify
    })
    it('Integration: Title contains id of book', () => {
        chai.request(app).get('/books/42').end((err, res) => {
            const dom = new jsdom.JSDOM(res.text)
            const h1 = dom.window.document.querySelector('h1')
            expect(h1).to.contain('42')
        });
    })
    afterEach(() => { aNumber = 0; })       // Teardown
})
----

=== Cypress
Erlaubt komplexe E2E mit einem Mocha/Chai-ähnlichen Syntax. Läuft in einem eigenen Test-Runner mit Browser-Dashboard.

[source, javascript]
----
describe('Cypress-Fixture', () => {
  it('E2E: Clear button clears the form', () => {
    cy.visit('localhost:3001/orders')
    const input = cy.get('input[name="email"]')
    input.type('Typing...')
         .should('have.value', 'Typing...')
    cy.get('#clear-button').click()
    input.should('have.value', '')
  })
})
----
footnote:[`cy.url()` gibt die aktuelle URL zurück. `cy.submit()` sendet ein Formular ab.]
footnote:[`cy.contains("Hello")` gibt das erste Element mit dem Text "Hello" zurück.]