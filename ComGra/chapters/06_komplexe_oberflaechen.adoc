== Komplexe Oberflächen

[.not-in-cheatsheet]
=== Grundformen
3D-Objekte lassen sich wie bisher durch Punkte, aber auch durch Funktionen beschreiben:

* *Funktionen*: Kontinuierlicher Wertebereich
    ** Explizit: stem:[z = -ax + by + ...]
    ** Implizit: stem:[0 = x^2 + 2y^2 + ...]
    ** Parametrisch: stem:[P = vec 0 + s vec u + ...]
* *Punkte*: Festgelegter Wertebereich

footnote:[Explizite Funktionen sind nach einer Variablen aufgelöst.]
footnote:[Implizite sind nicht aufgelöst (algebraische Oberflächen).]
footnote:[Algebraische Oberflächen: Sphäre, Torus, Würfel, etc.]

==== Kombinationen
Punkte und Funktionen sind die Grundbausteine für alle komplexen Formen:

* *Aus Primitiven*: Punktwolke, Meshes
* *Approximierend*: Iso-Surface, Splines
* *Konstruiert*: Subdivision Surfaces, Fraktale

==== Vor- und Nachteile
Es gibt keine beste Repräsentationsform für Objekte. Vor- und Nachteile sind:

* *Funktionen*:
    ** *Vorteile*: Wenig Speicherplatz, Schnittpunkte mathematisch berechenbar, beliebig genaue Auflösung
    ** *Nachteile*: Beschränkte Formen, komplexe Herleitung, grafische Transformationen sind schwierig
* *Punkte*:
    ** *Vorteile*: Beliebige Geometrie, vielseitig einsetzbar, direkter GPU-Support, einfache Berechnung
    ** *Nachteile*: Fixe Genauigkeit, hoher Speicherbedarf, Rechenzeit abhängig von der Anzahl Primitiven

=== Triangulation
[.not-in-cheatsheet]
Beschreibt die Umwandlung einer Punktwolke in ein Polygon-Mesh.

footnote:[Die Oberflächen werden rekonstruiert / approximiert.]
footnote:[Wird z.B. bei Rohdaten von 3D-Scans angewandt.]

'''

[.inlined.tiny]
[cols="1,1"]
|===
a| image::sweep-strategie.jpg[]
a| image::insert-strategie.jpg[]

| Sweep-Strategie
| Insert-Strategie
|===

==== Sweep-Strategie
. Laufe von *links* nach *rechts*.
. Für jeden Punkt:
    .. Zeichne eine Linie zu den *2* vorherigen Punkten, für die gilt:
        ** Keine Dellen entstehen
        ** Keine Überschneidungen entstehen
    .. Verbinde nun alle weiteren Punkte innerhalb dieser Form.
. Wiederhole, bis zum Ende.

footnote:[Die entstehende Form nennt sich «Konvexe Hülle».]

==== Insert-Strategie
. Zeichne *2* Anfangsdreiecke um alle Punkte.
. Für alle Punkte (zufällige Wahl):
    .. Bestimme das umfassende Dreieck.
    .. Unterteile dieses Dreieck in 3 weitere Dreiecke. D.h. Verbinde alle Eckpunkte mit dem gewählten Punkt.
. Wiederhole, bis zum Ende.
. Entferne nun alle künstlichen Anfangs**punkte** und die damit verbundenen Dreiecke.

[.not-in-cheatsheet]
==== Probleme
Beide Strategien können «unschöne», d.h. spitze Dreiecke erzeugen.

footnote:[Wir können dies mit «Delaunay» nachträglich verbessern.]
footnote:[Teilweise lassen sich spitze Winkel jedoch nicht vermeiden.]

===== Delaunay Triangulation

[.align-left]
[.inlined]
[cols="4,1"]
|===
a| . Rekursiv für alle Dreiecke:
.. Wähle ein anliegendes Dreieck
.. Ersetze die längere der inneren Kanten durch die Kürzere. (Edge-Flip)
. Wiederhole, bis zum Ende.
a| image::edge-flip-example.png[]
|===

=== Approximationen
==== Marching Squares Algorithmus
[.not-in-cheatsheet]
Mit diesem Algorithmus lassen sich Isolinien von Heat Maps diskret bestimmen.

. Gitter über die Daten legen.
. Betrachtungshöhe (Potenzial) festlegen.
. Für alle Quadrate im Gitter:
    .. Eckpunkte beachten.
    .. Nach Schema unten Linien einzeichnen.
. Wiederhole, bis zum Ende.

footnote:[«Heat Map»: 2D-Visualisierung von 3D-Landschaften.]
footnote:[«Isolinien»: Die Höhenlinien einer Heat Map.]

'''

[.not-in-cheatsheet]
image::marching-squares-algorithm.jpg[]

[.not-in-cheatsheet]
==== Weitere Algorithmen

* Marching Cubes (3D-Heat-Maps)
* Interpolation: Punkte «vervollständigen»
    ** Polynomial: stem:[f=a_0x^0 + ... + a_nx^n]
    ** Splines: Stückweise Interpolation der Punkte mit linearen, quadratischen oder kubischen Funktionen.
* NURBS: Approximation von 3D-Flächen

'''

image::interpolation.jpg[]

[.not-in-cheatsheet]
=== Lindenmayer Systeme
L-Systeme beschreiben beliebig feine, selbstähnliche geometrische Strukturen.

footnote:[Sie können rekursiv definiert und aufgebaut werden.]

==== Formale Definition

* Anfangsform [.smaller]#(z.B. Strich)#: stem:[f]
* Ersetzungsregeln: stem:[f rarr f+f--f+f]
    ** Ersetzungsmöglichkeit: stem:[f]
    ** Positive Rotation: stem:[+]
    ** Negative Rotation: stem:[-]
    ** Abzweigung (Kind): stem:[\[f\]]
* Kontext: Rotation stem:[60°]

footnote:[Beispiele: Koch Kurve, Hilbert Kurve, Fraktale, etc.]
footnote:[So lassen sich u.a. Bäume generieren (z.B. mit Zufallszahlen).]

'''

image::lindenmayer-systems.jpg[]

=== Subdivision Surfaces
[.not-in-cheatsheet]
Beschreibt ein rekursives Verfahren für das Verfeinern von Oberflächen.

footnote:[Subdivision Curves ist das Äquivalent für Kurven.]

==== *Curves*: Chaikin’s Algorithmus
. Beginne mit einer Kurve
. Markiere die Anfangspunkte (Blau)
. Setze in der Mitte von *allen* Strecken einen neuen Punkt (Schwarz ohne Füllung)
. Setze nun in der Mitte von allen *neuen* Strecken einen Punkt (Rot)
. Streiche nun alle schwarzen Punkte und verbinde die Roten und Blauen.
. Wiederhole, solange wie gewünscht.

footnote:[Die neuen Punkte stehen an stem:[1 \/ 4] und stem:[3 \/ 4] der Originalstrecke.]
footnote:[Diese Gewichtung kann auch variiert werden.]

'''

image::subdivision-surface.jpg[]

==== *Surfaces*: Algorithmen
[.compress-in-cheatsheet]
===== Dreiecksbasiert
[.inlined]
[cols="1,1"]
|===
| Loop
| stem:[sqrt(3)] Subdivision

a| image::subdivision-surfaces-loop.png[]
a| image::subdivision-surfaces-sqrt-3.png[]
|===

[.compress-in-cheatsheet]
===== Rechtecksbasiert
[.inlined]
[cols="1,1"]
|===
| Catmull-Clark
| Doo-Sabin

a| image::subdivision-surfaces-catmull-clark.png[]
a| image::subdivision-surfaces-doo-sabin.png[]
|===

[.not-in-cheatsheet]
==== Vorteile
Vorteile von Subdivision-Surface, insbesondere im Vergleich zu NURBS:

* Beliebige Oberflächentopologie
* Kompakte Repräsentation
* Level-of-Detail Rendering
* Intuitiv mit einfachen Algorithmen

footnote:[NURBS-Flächen können nur Scheiben, Zylinder oder Tori sein.]

=== Korrektur & Optimierung
[.not-in-cheatsheet]
3D-Modelle können aus verschiedenen Quellen stammen. Oftmals sind dabei folgende Qualitätsprobleme zu beobachten:

[.not-in-cheatsheet]
* Künstliche Unebenheiten der Flächen
* Zu grosse Datenmengen
* Schlechte Triangulierung wie z.B. topologische Inkonsistenz und spitze / ungleichmässige Dreiecke

'''

image::issues-with-3d-objects.png[]

[.not-in-cheatsheet]
==== Visualisierung von Fehlern
Um die genannten Qualitätsprobleme zu visualisieren, können wir z.B.:

* Die Reflexionslinien des Modells betrachten.
* Ungleichmässige Dreiecke basierend auf dem Kantenverhältnis einfärben.

[.not-in-cheatsheet]
==== Modell-Reparatur
Für die Verbesserung der Modellqualität gibt es verschiedenen Flächen- und Volumen-orientierte Algorithmen:

* *Flächen-orientierte Algorithmen*:
    ** *Vorteil*: Die assoziierten Oberflächeneigenschaften bleibt gut erhalten.
    ** *Nachteil*: Schlechte automatische Fehlererkennung und Behebung.
* *Volumen-orientierte Algorithmen*:
    ** *Vorteil*: Gute automatische Fehlererkennung und Behebung.
    ** *Nachteil*: Oft zu detailliert und mit Verlust der Oberflächeneigenschaften.

footnote:[z.B.: Mesh Smoothing, Mesh Reduktion, Remeshing, etc.]
footnote:[Mesh Smoothing ist für dieses Modul nicht relevant.]

==== Mesh Reduktion / Remeshing
[.not-in-cheatsheet]
Mit diesen Verfahren wollen wir die Anzahl Vertices und Faces reduzieren.

===== Vertex Clustering
. Wähle ein Grösse stem:[Ɛ] (Toleranz)
. Teile den Raum in Quadrate dieser Grösse
. Berechne pro Quadrat *einen* repräsentativen Eckpunkt (z.B. Mittelpunkt aller Punkte)
. Lösche die originalen Punkte und ersetzte sie durch den neuen Eckpunkt.

[.not-in-cheatsheet]
Je nach Berechnungsverfahren des repräsentativen Eckpunkts kann sich die Topologie des Meshes stark unterscheiden.

footnote:[Das Verfahren spielt also eine starke Rolle für die Qualität.]
footnote:[Allgemein gilt: Laufzeit stem:[O(n)] mit möglichen Alias Errors.]

'''

[.not-in-cheatsheet]
image::vertex-clustering-variants.png[]

[.inlined.tiny.not-in-cheatsheet]
[cols="1,1,1,1"]
|===
| Original
| Durchschnitt
| Median
| Least Squares
|===

footnote:[Am besten geeignet ist also der «Least Squares»-Algorithmus.]
footnote:[D.h.: Minimiere den quadrierten Abstand zur Oberfläche.]

[.not-in-cheatsheet]
===== Inkrementelle Reduktion
Sequenzielle Anwendung von zwei primitiven Reduktionsoperationen:

* Eckpunkt entfernen
* Kante kollabieren (zusammenlegen)

Die Reihenfolge der Operationen wird durch eine globale Metrik (den Approximationsfehler) bestimmt.

footnote:[Diese Metrik muss bei jeder Reduktion neu berechnet werden.]
footnote:[Allgemein gilt: Laufzeit stem:[O(n log n)] bis stem:[O(n²)] ohne Alias Errors.]

[.not-in-cheatsheet]
===== Resampling / Remeshing
Komplette Neuberechnung des Meshes, wobei die Struktur auf verschiedene Arten verändert werden kann:

* Wechsel von Dreiecke auf Vierecke
* Verwendung von gleichmässigen Dreiecken
* Variieren der Flächendichte
* Erhöhung der Regularität der Struktur

footnote:[Die Eckpunkte des neuen Meshes müssen dabei nicht zwingend mit denen des alten Meshes assoziiert sein.]
footnote:[Alias Errors sind jedoch weiterhin möglich.]

'''

image::remeshing-example.png[]

[.not-in-cheatsheet]
==== Alias Error
Beschreibt die inkorrekte Approximation eines Meshes aufgrund mangelnder Abtastgenauigkeit.

footnote:[z.B.: Zu grosse Toleranz stem:[Ɛ] beim «Vertex Clustering».]

'''

[.inlined.tiny]
[cols="1,1"]
|===
a| image::alias-error-original.png[]
a| image::alias-error-approximation.png[]

| Original
| Approximation
|===
