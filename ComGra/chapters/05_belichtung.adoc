== Beleuchtung & Texturen
[.not-in-cheatsheet]
=== Allgemeines
Die Farbe eines Objekts (bzw. Pixels) setzt sich zusammen aus:

* Den Objekt-Farben / Texturen
* Der Beleuchtung

footnote:[Oftmals verwenden wir dabei RGB-Farben: stem:[C = (R, G ,B)].]
footnote:[Remission: Beschreibt das Abprallen von Licht auf Objekten.]

[.not-in-cheatsheet]
=== Farbdarstellung
==== Subtraktive Farbberechnung
Nur die Farbanteile, welche in Lichtquelle und Objekt vorkommen, sind sichtbar:

[stem]
++++
    C_"Total" = ((R_"Light" * R_"Object"),(G_"Light" * G_"Object"),(B_"Light" * B_"Object"))
++++

Alternative mit gemittelten Werten:
[stem]
++++
    C_"Total" = 1/(2) * (C_"Light" + C_"Object")
++++

footnote:[Subtraktiv, da die fehlenden Farben *nicht* remittiert werden.]


==== Additive Farbberechnung
Die Farbanteile der Lichtquellen werden zusammengerechnet:

[stem]
++++
    C_"Total" = vec 1 - (((1 - R_"L1") * (1- R_"L2")),((1 - G_"L1") * (1- G_"L2")),((1 - B_"L1") * (1- B_"L2")))
++++

footnote:[Die *nicht enthaltenen* Lichtanteile werden
reduziert.]

=== Oberflächennormale
[.not-in-cheatsheet]
Nicht-triviale Belichtungsmodelle berücksichtigen die Ausrichtung der Oberfläche:

[stem]
++++
    "N"_(V_1) =  (V_2 - V_1) xx (V_3 - V_1)
++++

footnote:[Normale eines Vertex stem:[V_1] von einer Fläche stem:[F in (V_1,V_2,V_3)]]
footnote:[Dieser Wert wird nun auf die Fläche stem:[F] interpoliert.]
footnote:[Kann im voraus oder «on-the-fly» berechnet werden.]

'''

[.not-in-cheatsheet]
image::example-normals.png[]

=== Beleuchtungsmodelle
==== Ambient Lighting
[.not-in-cheatsheet]
Belichtung von einem globalen Licht mit Remission in alle Richtungen.

image::ambient-lighting.jpg[]

'''

[.not-in-cheatsheet]
[source,glsl]
----
void main() {
  vec3 ambient = strength * lightColor;
  vec3 color = ambient * objectColor;
  fragColor = vec4(color, 1.0);
}
----
[.code-annotation]#Fragment Shader#

==== Diffuse Lighting
[.not-in-cheatsheet]
Belichtung von einer Punktquelle mit Remission in alle Richtungen.

image::diffuse-lighting.jpg[]

[.not-in-cheatsheet]
[source,glsl]
----
void main() {
  vec3 normDir = norm(normal);
  vec3 lightDir = norm(lightPos - fragPos);
  float cosTheta
    = max(dot(normDir, lightDir), 0.0);
  vec3 diffuse = cosTheta
                 * lightColor
                 * objectColor;
  fragColor = vec4(diffuse, 1.0);
}
----
[.code-annotation]#Fragment Shader#
footnote:[Wird für *matte* Oberflächen verwendet.]
footnote:[Das `+norm+` steht für die Funktion `+normalize+`.]

==== Specular Lighting
[.not-in-cheatsheet]
Belichtung von einer Punktquelle mit Remission in *eine* Richtung.

image::specular-lighting.jpg[]

[.not-in-cheatsheet]
[source,glsl]
----
void main() {
  vec3 normDir = norm(normal);
  vec3 camDir = norm(camPos - fragPos);
  vec3 lightDir = norm(lightPos - fragPos);
  vec3 reflectDir
    = reflect(-lightDir, normDir);
  float cosTheta
    = max(dot(camDir, reflectDir), 0.0);
  float strength = pow(cosTheta, shininess);
  vec3 specular = strength
                  * lightColor
                  * objectColor;
  fragColor = vec4(specular, 1.0);
}
----
[.code-annotation]#Fragment Shader#
footnote:[Wird für *spiegelnde* Oberflächen verwendet.]

=== Kombinationsmodelle
==== Phong-Shading
[.not-in-cheatsheet]
Die Belichtung wird aus Ambient-, Diffuse- und Specular-Anteilen zusammengesetzt.

[stem]
[.smaller]
++++
C_"Total" = 1/(3) * (C_"Ambient" + C_"Diffuse" + C_"Specular")
++++

footnote:[Problem: Ab 90° gibt es keine Spiegelung mehr.]

==== Blinn-Phong-Shading
[.not-in-cheatsheet]
Löst das Problem von Phong-Shading durch die Verwendung eines sogenannten «Halfway-Vectors».

image::blinn-phong-shading.jpg[]

[.not-in-cheatsheet]
[source,glsl]
----
void main() {
  ...
  vec3 halfwayDir = norm(lightDir + camDir);
  float cosTheta
    = max(dot(normDir, halfwayDir), 0.0);
  ...
}
----
[.code-annotation]#Fragment Shader#

[.not-in-cheatsheet]
=== Texturen
Texturen sind Bilddateien, welche Eigenschaften (wie z.B. die Farbe) einer Oberfläche definieren.

==== Texture-Mapping
Beschreibt die Abbildung von 3D-Vertex-Koordinaten auf 2D-Textur-Koordinaten.

image::uv-mapping.png[]

footnote:[Auch UV-Mapping genannt.]
footnote:[Sampling: Umrechnung von Fragment- in Texturkoordinaten.]

'''

=== HDR & HDRI
A High Dynamic Range Image is a 360° image for lighting and background purposes. It is created by mixing several images of the same scene with different exposures. It stores the three color values with floating point precision. These photos contain 32 bits per pixel per channel, which is much more than the traditional 8-bit.

[.not-in-cheatsheet]
[source,glsl]
----
void main(void) {
  fragColor = texture(texUnit, texCoord);
}
----
[.code-annotation]#Fragment Shader#