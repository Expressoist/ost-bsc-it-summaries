== Projektionen
=== Definition
Um ein 3D-Objekt auf einem 2D-Bildschirm darzustellen, müssen wir es zuerst in diese 2D-Dimension projizieren. Wir unterscheiden dabei:

* Perspektivische Projektion
* Orthogonale Projektion

'''

image::types-of-projections.jpg[]

==== Perspektivische Projektion
Projiziere den Punkt stem:[P(x, y, z)] auf die XY-Ebene (stem:[z = 0]) basierend auf der Kameraposition stem:[E(e_x, e_y, e_z)].

Gesucht ist die Projektion stem:[C(c_x, c_y)].

[.inlined]
[cols="1,1"]
|===
| stem:[c_x = (e_x z - e_z x)/(z - e_z)]
| stem:[c_y = (e_y z - e_z y)/(z - e_z)]
|===

footnote:[Die Dimension wird also um eins reduziert (stem:[RR]³ zu stem:[RR]²).]
footnote:[Bei 2D einfach eine Komponente (z.B. stem:[x]) weglassen.]

==== Orthogonale Projektion
Projiziere den Punkt stem:[P(x, y, z)] auf die XY-Ebene (stem:[z = 0]) basierend auf der Kameraposition stem:[E(e_x, e_y, e_z)].

Gesucht ist die Projektion stem:[C(c_x, c_y)].

[.inlined]
[cols="1,1"]
|===
| stem:[c_x = x]
| stem:[c_y = y]
|===

=== View Frustum
Bezeichnet die Sichtbarkeit (Clip-Space) bei der perspektivischen Projektion. Es wird definiert durch:

* Öffnungswinkel (Field of View)
* Seitenverhältnis (Aspect Ratio)
* Near und Far-Plane (Clipping Distance)

footnote:[Der Öffnungswinkel bestimmt die Grösse von Objekten.]
footnote:[Die Brennweite (Kamera) bestimmt die Tiefenschärfe.]

== GPU-Berechnung
=== Grafik-Pipeline

image::graphics-pipeline.png[]

=== Double Buffering
TODO

=== Shader-Programme
Sind auf der GPU laufende Programme für die Berechnung des Bildes. Es gibt:

* *Vertex-Shader*: Projektion der Modell-Eckpunkte in den Clip-Space.
* *Fragment-Shader*: Berechnung der Farbe eines Pixels.

footnote:[Arbeitet immer in *einzelnen* Primitiven (z.B. *ein* Eckpunkt).]

==== GLSL Programmiermodell
Kommunikation in den Pipeline-Stages:

* `+in+`: Aus vorherigem Stage
* `+out+`: An nächsten Stage
* `+uniform+`: Für alle Primitiven gleich

[source,glsl]
----
in vec3 positionIn;
in vec3 normalIn;
out vec3 normal;

// Transformations to Clip-Space
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
  // Homogene Transformation
  gl_Position = vec4(positionIn, 1.0)
                * model
                * view
                * projection;

  normal = vec4(normalIn, 1.0)
           * model;
}
----
[.code-annotation]#vertex-shader.glsl#
footnote:[`+in+` und `+out+` verwenden dabei «matching by name».]