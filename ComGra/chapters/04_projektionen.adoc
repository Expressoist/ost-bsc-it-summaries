== Projektionen
=== Definition
[.not-in-cheatsheet]
Um ein 3D-Objekt auf einem 2D-Bildschirm darzustellen, müssen wir es zuerst in diese 2D-Dimension projizieren. Wir unterscheiden dabei:

[.not-in-cheatsheet]
* Perspektivische Projektion
* Orthogonale Projektion

'''

image::types-of-projections.jpg[]

[.compress-in-cheatsheet]
=== Berechnung
[.not-in-cheatsheet]
Projiziere den Punkt stem:[P(x, y, z)] auf die XY-Ebene (stem:[z = 0]) basierend auf der Kameraposition stem:[E(e_x, e_y, e_z)].

[.not-in-cheatsheet]
Gesucht ist die Projektion stem:[C(c_x, c_y)].

footnote:[Die Dimension wird also um eins reduziert (stem:[RR]³ zu stem:[RR]²).]
footnote:[Bei 2D einfach eine Komponente (z.B. stem:[x]) weglassen.]

==== Perspektivisch
[.inlined.with-padding]
[cols="1,1"]
|===
| stem:[c_x = (e_x z - e_z x)/(z - e_z)]
| stem:[c_y = (e_y z - e_z y)/(z - e_z)]
|===

footnote:[Herleitung aus der Formel stem:[y = Δy \/ Δz * z + c]]

==== Orthogonal
[.inlined.with-padding]
[cols="1,1"]
|===
| stem:[c_x = x]
| stem:[c_y = y]
|===

[.not-in-cheatsheet]
=== View Frustum
Bezeichnet die Sichtbarkeit (Clip-Space) bei der perspektivischen Projektion. Es wird definiert durch:

* Öffnungswinkel (Field of View)
* Seitenverhältnis (Aspect Ratio)
* Near und Far-Plane (Clipping Distance)

footnote:[Der Öffnungswinkel bestimmt die Grösse von Objekten.]
footnote:[Die Brennweite (Kamera) bestimmt die Tiefenschärfe.]

== GPU-Berechnung
=== Grafik-Pipeline

image::graphics-pipeline.png[]

[.not-in-cheatsheet]
=== Double Frame Buffering
Beschreibt die *abwechselnde* Verwendung von zwei Framebuffer für die Berechnung und Darstellung eines Frames.

* *Frame*: Bild auf dem Display
* *Framebuffer*: Speicherort des Frames

footnote:[Berechnungen werden nicht auf dem Anzeigebild durchgeführt.]
footnote:[So können Berechnungsartefakte vermieden werden.]

[.not-in-cheatsheet]
=== Shader-Programme
Sind auf der GPU laufende Programme für die Berechnung des Bildes. Es gibt:

* *Vertex-Shader*: Projektion der Modell-Eckpunkte in den Clip-Space.
* *Fragment-Shader*: Berechnung der Farbe eines Pixels.

footnote:[Arbeiten immer mit *einzelnen* Primitiven (z.B. *ein* Eckpunkt).]

==== GLSL Programmiermodell
Kommunikation in den Pipeline-Stages:

* `+in+`: Aus vorherigem Stage
* `+out+`: An nächsten Stage
* `+uniform+`: Für alle Primitiven gleich

[source,glsl]
----
in vec3 positionIn;
in vec3 normalIn;
out vec3 normal;

// Transformations to Clip-Space
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
  // Homogene Transformation
  gl_Position = vec4(positionIn, 1.0)
                * model
                * view
                * projection;

  // Component-wise multiplication
  normal = vec4(normalIn, 1.0) * model;
}
----
[.code-annotation]#Vertex Shader#
footnote:[`+in+` und `+out+` verwenden dabei «matching by name».]