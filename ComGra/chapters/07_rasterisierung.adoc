== Rasterisierung & Sichtbarkeit
=== Rasterisierung
[.not-in-cheatsheet]
Da ein 2D-Bildschirm aus Pixeln besteht, müssen wir nach der Projektion die Linien noch in ein Raster abbilden. Es gibt verschiedene Methoden dazu:

[.not-in-cheatsheet]
* Vollständig Zusammenhängend
* Minimal Zusammenhängend
    ** Aliased (Binär)
    ** Anti-Aliased (Prozentual)

'''

[.not-in-cheatsheet]
image:lines-and-rasterisation.jpg[]


==== Aliasing
Zeichne ausschliesslich die Pixel eines Dreiecks, für die gilt:

* Das Pixel-Zentrum liegt *in* dem Dreieck.
* Das Pixel-Zentrum liegt *auf* der oberen oder linken Seite des Dreiecks.
    ** Bei *Eckpunkten* muss das Zentrum auf der oberen *und* linken Seite liegen.
    ** Zwei *linke* Seiten sind auch gültig.

footnote:[Achtung: Die obere Seite muss dazu exakt horizontal sein.]
footnote:[Technisch wird das Dreieck **zeilen**weise gezeichnet.]
footnote:[Dazu wird u.a. der Bresenham Linien-Algorithmus verwendet.]

===== Bresenham Linien-Algorithmus
[.not-in-cheatsheet]
Basierend auf zwei Punkten stem:[P_"Start"] und stem:[P_"Ende"], zeichne die Linie nach dem Bresenham Linien-Algorithmus:

. Berechne stem:[Δx = x_"Ende" - x_"Start"]
. Berechne stem:[Δy = y_"Ende" - y_"Start"]
. Berechne stem:[m = Δy \/ Δx]
. Wenn stem:[Δx >= Δy] dann mit stem:[i = 0]:
.. stem:[x_i = x_"Start" + i]
.. stem:[y_i = y_"Start" + floor(m * i + 0.5)]
.. Zeichne den Pixel stem:[P(x_i, y_i)]
.. stem:[i larr i + 1]

footnote:[Bei stem:[Δx < Δy] wird die Berechnung von stem:[x_i] und stem:[y_i] vertauscht.]

==== Anti-Aliasing
ifndef::cheatsheet[]
Zeichne alle Pixel eines Dreiecks unter Beachtung der prozentualen Abdeckung. Das bedeutet:

* Erhöhe das Pixelraster (z.B. 4x)
* Berechne die Abdeckung nach Aliasing
* Reduziere das Pixelraster und zeichne alle Pixel anhand der berechneten Abdeckung.

Varianten davon sind:

* *Super-Sampling*: Die komplette GPU-Pipeline läuft mit einem erhöhten Pixelraster.
* *Multisampling*: Nur der Z-Buffer läuft mit einem erhöhten Pixelraster.

footnote:[Die Objektränder erhalten also eine «weiche» Transparenz.]

'''
endif::[]

image::aliasing-variants.png[]

[.not-in-cheatsheet]
==== Probleme (Aliasing Effekte)
Wenn die Auflösung eines Texturmusters grösser ist als die Auflösung der Anzeigefläche, kann der Moiré-Effekt auftreten.

footnote:[Dies ist bei beiden Aliasing-Verfahren der Fall.]
footnote:[Problem: Ein Pixel alleine kann kein Muster darstellen.]

===== Mipmaps
Beschreibt eine «Pyramide» von Texturen, bei der die Auflösung anhand der Distanz zur Kamera gewählt wird.

footnote:[Je näher das Objekt, desto hochauflösender die Textur.]
footnote:[Damit kann der Moiré-Effekt verhindert werden.]

'''

image::mipmap-example.png[]

=== Sichtbarkeit
==== Z-Buffer (Depth-Buffer)
[.not-in-cheatsheet]
Erlaubt das korrekte Zeichnen von überlappenden Objekten.

[.not-in-cheatsheet]
* Initialisiere den Buffer mit [.smaller]#stem:[Z_"B" = oo"]#
* Für alle Objekt-Pixel:
    ** Ermittle die Distanz zur Kamera [.smaller]#stem:[Z_"O"]#
    ** Wenn [.smaller]#stem:[Z_"B" > Z_"O"]#:
        *** Zeichne das Pixel und setze [.smaller]#stem:[Z_"B" larr Z_"O"]#.
    ** Wenn [.smaller]#stem:[Z_"B" <= Z_"O"]#:
        *** Zeichne das Pixel nicht

footnote:[«Z-Fighting»: Berechnungsartefakt bei identischen Z-Werten.]
footnote:[Oftmals wird stem:[Z_"O" = 1 - 1 \/ z] als Wert verwendet.]

'''

[.inlined]
[cols="1,1,1"]
|===
a| image::z-buffer-example-1.png[]
a| image::z-buffer-example-2.png[]
a| image::z-buffer-example-3.png[]
|===

== Spiegelungen & Schatten
=== Spiegelungen
[.tiny]
[.inlined]
[cols="1,1"]
|===
a| image::mirror-projection-flat.png[]
a| image::mirror-projection-sphere.png[]

| Fläche
| Kugel
|===

[.not-in-cheatsheet]
==== Flächen
Berechne die Szene aus Sicht einer virtuellen Spiegelkamera und projiziere das Bild in Form einer Textur auf die Fläche.

footnote:[Winkel und Distanz sind dabei äquivalent.]

[.not-in-cheatsheet]
==== Kugeln
Berechne die Szene für alle Seiten einer umliegenden Bounding-Box und projiziere das Bild dann auf die Kugel.

footnote:[Die Spiegelkamera steht dabei in der Kugelmitte.]
footnote:[Je grösser die Bounding-Box, desto kleiner der Fehler.]

==== Berechnungen
[.not-in-cheatsheet]
Basierend auf einem Spiegel an Position stem:[M] mit der Normalen stem:[vec n] und einer Kamera an Position stem:[E]. Berechne die Position der Spiegelkamera stem:[E^'].

[.inlined.with-padding]
[cols="1,1"]
|===
| stem:[vec v = E - M]
| stem:[vec d = ((vec n circ vec v) / (\|vec n\|^2)) * vec n]

2.1+| stem:[E^' = E - 2 * vec d]

|===

footnote:[Es handelt sich dabei um eine orthogonale Projektion, welche uns die Distanz [.smaller]#stem:[d]# von der Kamera zum Spiegel liefert.]

[.not-in-cheatsheet]
=== Environment Mapping
Beschreiben 360°-Bilder, welche für Spiegelungen und Hintergründe verwendet werden können.

footnote:[z.B. Cube-Maps, Sphere-Maps, Cylinder-Maps, etc.]

=== Schatten
==== Shadow Mapping
[.not-in-cheatsheet]
Projiziere die Szene aus Sicht der Lichtquelle auf die zu belichtende Oberfläche.

footnote:[Zeichne zuerst die Schatten und dann die Objekte.]
footnote:[Bilde dazu nicht die Farbwerte, sondern die Tiefenwerte ab.]

'''

image::shadow-mapping-projection.png[]

==== Depth-Map
Visualisierung des Z-Buffers.

* Schwarz: stem:[Z_O=0] (Nahe)
* Weiss: stem:[Z_O=oo] (Weit weg)

'''

[.not-in-cheatsheet]
image::depth-map.png[]
