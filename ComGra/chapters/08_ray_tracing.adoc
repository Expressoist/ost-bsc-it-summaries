== Ray Tracing
=== Generierung von Primärstrahlen
image::ray-tracing-primarstrahlen.png[]

=== Reflexionsberechnung
stem:[vec r = vec v - 2(vec n * vec v) * vec n]

image::ray-tracing-reflection.png[]

=== Quad-Tree (Acceleration structure)
* Adaptive, rekursive Aufteilung der Fläche
* Solange mehr als ein Punkt → Aufteilung in 4 gleich grosse, untergeordnete
Flächen

image::ray-tracing-quad-tree.png[]

[.not-in-cheatsheet]
== Ray Tracing Prinzip
=== Bildgenerierung


=== Verdeckung

=== Rekursive Weiterverfolgen
Farbe des Elements (am Schnittpunkt) hängt ab von:

* Farbe & Intensität sichtbarer Lichtquelle in Umgebung
* Richtung Lichtquelle
* Oberflächenfarbe & -beschaffenheit
* Position Beobachter

Zur Berechnung der Objektfarbe, Strahlenbrechung rekursiv weiterführen (Sekundärstrahlen)

* Strahlen können beliebig oft reflektiert werden (irgendwann muss abgebrochen werden)

=== Rückweg aus Rekursion
* Beim Rückweg kann Farbe & Licht-Intensität bestimmt werden
* *Baumstruktur:* Strahl erzeugt beim auftreffen mehrere Folgestrahlen

=== Ray Tracing
Von der Kamera aus werden Strahlen durch alle Pixel der Bildebene verfolgt und mit der Szene geschnitten. Bei einem primitiven, einstufigen Ray Tracing bestimmt die Objektfarbe am Schnittpunkt die Pixelfarbe. In der Regel wird beim Aufschlagpunkt einer oder mehrere Reflktionsstrahlen berechnet und diese rekursiv weiterverfolgt.  Entsprechend wird die Pixelfarbe auf dem Weg zurück aus der Rekursion zusammengerechnet, in der Regel auch unter Einbezug der Strahlen zu den Lichtquellen. 

* *Triangle-Meshes:* Operation relativ rechenintensiv
* *Elemente mit impliziter Darstellung:* oft sehr effizient berechnet
    ** z.B. für Kugel stem:[(x - c_"x")^2+(y-c_"y")^2-r^2=0] kann für stem:[(x, y)] der parametrische Strahl stem:[0+t vec v] eingesetzt und nach stem:[t] aufgelöst werden => liefert Schnittpunkt

[.not-in-cheatsheet]
== Minimal Ray Tracer (vereinfacht)
=== Generieren von Primarstrahlen
Kamera im Ursprung & Projektfläche mit Höhe 1 im Abstand z

* stem:[d =  1/h]
* stem:[p_"x"(0)=(w-1)d/2]
* stem:[p_"y"(0)=(h-1)d/2=1/2-1/(2h)]
* Inkrement von stem:[p_"x",p_"y":d]
* Strahlen durch Ursprung und stem:[(p_"x",p_"y",z)]: stem:[0+t*normalize(p_"x",p_"y",z)]

*Am einfachsten:*
* Rudimentären, nicht Performance optimierten Ray Tracer
* Kugeln und Ebenen haben einfache implizite Gleichungen

=> TODO: Keine Ahnung wie viel man davon noch aufschreiben soll, sind viele Berechnungen die wahrscheinlich nicht kommen

[.not-in-cheatsheet]
== Acceleration Structures
=== Bounding Volume Hierarchies
==== Acceleration Structures

==== Axen-alierte Bounding Box

==== Bounding Volumes

==== Bounding Volumes Hierarchy (BVH)

[.not-in-cheatsheet]
== Raumteilende Strukturen
*Voxel:* Zellen im Raum

=== Uniform Grid
* Raum in gleich grosse Zellen Aufteilen (Voxels)
* Jede Zelle hat Referenz auf alle Primitiven, welche sich überlappen
* Strahlenschnitt
    ** Mit Bresenham (Algorithmus) Voxels in Strahlenrichtung traversieren
    ** Mit allen den individuellen Voxels zugeordneten Elementen
    ** Abbruch bei ersten geschnittenen Primitive
* Auflösung Grid
    ** *zu tief:* Keine Reduktion der Anzahl Schnitt-Tests
    ** *zu hoch:* Unnötig hoher Traversierungsaufwand

=== Uniform Grid Heuristik
* Anzahl Voxel = ca. Anzahl Primitiven
* Funktioniert gut bei uniformer Verteilung der Primitiven

=== Quad-Tree
TODO

=== Advanced Ray Tracing
* Ray-tracing wurde lange als Technik verstanden um fotorealistische Bilder zu berechnen. Das ist aber nicht ganz korrekt
* Fotorealistische, computergenerierte Bilder sind eine Kombination aus "light transport algorithm" und einer Technik, um die Sichtbarkeit zwischen Oberflächen zu berechnen (rasterization, ray-tracing) 

==== Whitted Ray Tracing (1980)
Die Farbe eines Punktes auf einer Oberfläche besteht aus 3 Komponenten:

* Oberflächenfarbe am Schnittpunkt unter Berücksichtigung des Lictes aller direkt sichtbaren Lichtquellen (Phong-Shading)
* Farbe des Lichtes aus der reflektierten Richtung
* Farbe des Lichtes aus Richtung der Lichtbrechung 

==== Cook, 1984
*Kamera-Linsen-Effekt*

* Objekte nicht in Fokusebene, erscheinen unscharf
* Jeder Punkt wird als runde Scheibe abgebildet
* Verfolge mehrere Strahlen durch jeweils einen zufälligen Punkt auf der Linseu

*Bewegungsunschärfe*

Emmitierte Strahlen zu verschiedenen Zeitpunkten und berechne das Durchschnittsbild

==== Globale Beleuchtung
* Alle (nicht komplett schwarzen) Oberflächen (r)emittieren Licht
* Für Belichtung eines Punktes haben alle sichtbaren Oberflächen einen Einfluss
* Light Transport Algorithmus

==== Light Transport
* Approximation mittels Monte-Carlo Simulation durch Auswahl zufällig gewählten Richtungsvektoren

*Monte Carlo Simulation*

* Zufall verwenden um komplexe Berechnungen zu vereinfachen
* Für einzelne Punkte kann Lösung einfach berechnet werden
* Einzelne Lösungen können aggregiert werden, dass die exakte Lösung approximiert wird.

=== Realtime ray tracing
TODO

[.not-in-cheatsheet]
== Animation
Eine Folge zeitlich schnell hintereinander gereihten Bildern erscheint als Bewegung.

=== Explizite Berechnung
* In Computeranimation ist Modell mathematisch repräsentiert
* Die einfachste Möglichkeit ist Eigenschaften wie Position, Rotation oder Farbe explizit aufgrund der "Simulationszeit" zu berechnen

=== Key Frames und "tweening"
* Animation wird anhand von Schlüsselbildern aufgebaut
* Bilder dazwischen dienen dazu Bewegung flüssig und natürlich erscheinen zu lassen
* Ansatz für handgezeichnete wie auch computergenerierte Animationen

=== Grundlegende Techniken der Computeranimation
* Vom Künstler orchestiert (key frames)
* Data driven (motion capture)
* Procedural (simulation, calculation using physics formulas)

footnote:[Kommen auch kombiniert zum Einsatz]

=== Animation mittels Key Frames
Kommt bei Handlung zum Zuge, oder wenn sich ein Einfluss von "aussen" ändert

*Library für Interpolation:* Tween.js

*Mathematisch beschriebene Modelle:* 
*Szene:* Beschrieben durch Modellparameter
*Tweening:* Erreicht durch Interpolation der Parameter

Dafür bieten sich z.B. Splines an

* Gehen per Definition durch die Punkte
* Bilden einen kontinuierlichen Übergang dazwischen ab
